# -*- coding: utf-8 -*-
"""inventory_optimizer

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ztWU1KHzdJqfLMxvLckPWx46G2lkQsgs
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.holtwinters import ExponentialSmoothing

# 1. Load Dataset
file_path = input("Enter the path to your dataset (CSV or Excel): ")

if file_path.endswith('.csv'):
    df = pd.read_csv(file_path)
elif file_path.endswith(('.xls', '.xlsx')):
    df = pd.read_excel(file_path)
else:
    raise ValueError("Unsupported file type. Please use CSV or Excel.")

# Ensure necessary columns exist
required_cols = ['Product', 'Date', 'Sales', 'Stock']
for col in required_cols:
    if col not in df.columns:
        raise ValueError(f"Missing required column: {col}")

# Convert Date column to datetime
df['Date'] = pd.to_datetime(df['Date'])

# 2. Aggregate Sales by Product
sales_data = df.groupby(['Product', 'Date'])['Sales'].sum().reset_index()

# 3. Forecast Demand (using simple Holt-Winters)
forecast_horizon = int(input("Enter number of days to forecast: "))
products = sales_data['Product'].unique()

forecast_results = []

for product in products:
    product_sales = sales_data[sales_data['Product'] == product].set_index('Date').asfreq('D', fill_value=0)

    # Simple Exponential Smoothing forecast
    model = ExponentialSmoothing(product_sales['Sales'], trend="add", seasonal=None)
    model_fit = model.fit()
    forecast = model_fit.forecast(forecast_horizon)

    forecast_results.append(pd.DataFrame({
        'Product': product,
        'Forecast_Date': forecast.index,
        'Forecasted_Sales': forecast.values
    }))

forecast_df = pd.concat(forecast_results)

# 4. Calculate Optimal Reorder Point
lead_time = int(input("Enter lead time in days: "))
safety_stock = int(input("Enter safety stock quantity: "))

avg_sales = sales_data.groupby('Product')['Sales'].mean().reset_index()
avg_sales.rename(columns={'Sales': 'Avg_Daily_Sales'}, inplace=True)
avg_sales['Reorder_Point'] = avg_sales['Avg_Daily_Sales'] * lead_time + safety_stock

# 5. Merge with Current Stock to Identify Alerts
current_stock = df.groupby('Product')['Stock'].last().reset_index()
alerts = avg_sales.merge(current_stock, on='Product')
alerts['Status'] = np.where(alerts['Stock'] < alerts['Reorder_Point'], 'Understock', 'OK')
alerts['Status'] = np.where(alerts['Stock'] > alerts['Reorder_Point']*2, 'Overstock', alerts['Status'])

# 6. Visualization
for product in products:
    plt.figure(figsize=(10,5))
    product_data = sales_data[sales_data['Product'] == product]
    plt.plot(product_data['Date'], product_data['Sales'], label='Actual Sales')

    product_forecast = forecast_df[forecast_df['Product'] == product]
    plt.plot(product_forecast['Forecast_Date'], product_forecast['Forecasted_Sales'], label='Forecast', linestyle='--')

    plt.title(f"Sales & Forecast for {product}")
    plt.xlabel('Date')
    plt.ylabel('Sales')
    plt.legend()
    plt.show()

# 7. Display Alerts
print("\nInventory Alerts:")
print(alerts[['Product', 'Stock', 'Reorder_Point', 'Status']])